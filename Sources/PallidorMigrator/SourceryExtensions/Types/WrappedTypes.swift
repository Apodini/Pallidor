//
//  WrappedTypes.swift
//
//  Created by Andre Weinkoetz on 10/10/20.
//  Copyright Â© 2020 TUM LS1. All rights reserved.
//

import Foundation
import SourceryRuntime

/// Wrapper for sourcery type - used by parser to bundle identified source code types found in source code string
class WrappedTypes {
    internal init(classes: [WrappedClass], structs: [WrappedStruct], enums: [WrappedEnum]) {
        self.classes = classes
        self.structs = structs
        self.enums = enums

        if !self.classes.isEmpty {
            self.classes[0].nestedEnums = self.enums
        }
    }

    convenience init(types: [Type]) {
        let types = Types(types: types)
        self.init(from: types)
    }

    convenience init(from: Types) {
        self.init(
            classes: from.classes.compactMap { WrappedClass(from: $0) },
            structs: from.structs.compactMap { WrappedStruct(from: $0) },
            enums: from.enums.compactMap { WrappedEnum(from: $0) }
        )
    }

    enum CodeType {
        case `class`, `struct`, `enum`
    }

    /** returns the identified type found in source code string
     As all source files contain only a single type, every `WrappedType`
     only contains a single kind of source code type.
    */
    var type: CodeType {
        if !classes.isEmpty {
            return .class
        }
        if !structs.isEmpty {
            return .struct
        }
        if !enums.isEmpty {
            return .enum
        }
        return .class
    }

    /// All known classes
    private(set) var classes: [WrappedClass]

    /// All known structs
    private(set) var structs: [WrappedStruct]

    /// All known enums
    private(set) var enums: [WrappedEnum]

    /// Scans for all nested types and returns the first type found (either class, struct, enum or typealias)
    /// Must conform to `Modifiable` protocol
    /// Files generated by OpenAPI spec will always contain a single type only.
    /// - Returns: Identified modifiable
    func getModifiable() -> Modifiable? {
        // currently only case that's implemented
        if !classes.isEmpty {
            return classes.first
        }

        if !structs.isEmpty {
            return structs.first
        }

        if !enums.isEmpty {
            return enums.first
        }
        return nil
    }
}
